---
title:  "Java - 스레드의 생성과 실행"
excerpt: "스레드와 생성과 실행"

toc: true
toc_sticky: true
 
date: 2025-10-20
last_modified_at: 2025-10-20
---

### 스레드
- 스레드를 제대로 이해하려면, 자바 메모리 구조를 확실하게 알아야 한다.

### 자바의 메모리 구조
<img width="741" height="283" alt="image" src="https://github.com/user-attachments/assets/9326f8a5-b6d6-4a8b-ae54-a24e763950f0" /> <br />
- 메서드 영역 : 프로그램을 실행하는데 필요한 공통 데이터를 관리한다. 이 영역은 프로그램의 모든 영역에서 공유한다.
  - 클래스 정보 : 실행 코드(바이트 코드), 필드, 메서드와 생성자 등 모든 실행 코드
  - static area : static 변수들 보관
  - 런타임 상수 풀 : 프로그램을 실행하는데 필요한 공통 리터럴 상수 보관
- 스택 영역 : 자바 실행 시, 하나의 실행 스택이 생성된다. 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함
  - Stack Frame : 스택 영역에 쌓이며, 메소드를 호출할 때 마다 하나의 스택 프레임이 쌓이고, 종료되면 해당 프레임이 제거된다.
- 힙 영역 : 객체와 배열이 생성되는 영역이다. 가비지 컬렉션이 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.

> 스택 영역은 더 정확히 각 스레드별로 하나의 실행 스택이 생성된다. 따라서 스레드 수 만큼 스택이 생성된다.
> 지금은 스레드를 1개만 사용하므로 스택도 하나이다. 이후 스레드를 추가할 것인데, 그러면 스택도 스레드 수 만큼 증가한다.

### 스레드 생성
- 스레드를 만드는 방법에는 Thread 클래스를 상속 받는 방법과 Runnable 인터페이스를 구현하는 방법이 있다.
- 먼저 Thread 클래스를 상속 받아서 스레드를 생성해보자.

### 스레드 생성 - Thread 상속
```java
public class HelloThread extends Thread {

   @Override
   public void run() {
       System.out.println(Thread.currentThread().getName() + ": run()");
   }

}
```
- Thread 클래스를 상속하고, 스레드가 실행할 코드를 run() 메소드에 재정의한다.
- Thread.currentThread() 호출 시 해당 코드를 실행하는 스레드 객체를 조회한다.
- Thread.currentThread().getName() : 실행 중인 스레드의 이름을 조회한다.

```java
  public class HelloThreadMain {

    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName() + ": main() start");

        HelloThread helloThread = new HelloThread();
        System.out.println(Thread.currentThread().getName() + ": start() before");
        helloThread.start();
        System.out.println(Thread.currentThread().getName() + ": start() after");

        System.out.println(Thread.currentThread().getName() + ": main() end");
    }
  }
```
- 앞서 만든 HelloThread 스레드 객체를 생성하고 start() 호출
- start() 메소드는 스레드를 실행하는 메소드로, HelloThread 스레드가 run() 메서드를 실행한다.
- run() 메소드가 아닌, 반드시 start() 메소드를 실행해야 별도의 스레드에서 run() 코드가 실행된다.

<img width="705" height="246" alt="image" src="https://github.com/user-attachments/assets/50fcb759-6738-417a-b14e-065424f7654b" />

### 스레드 생성 전과 생성 후
<img width="736" height="778" alt="image" src="https://github.com/user-attachments/assets/c6d753f5-6179-492a-9815-9df2411d3287" /> <br />
**스레드 생성 전**
- 스레드의 생성 전에는 main 이라는 이름의 스레드가 실행하는 것을 확인할 수 있다.
- 프로세스가 작동하려면 스레드는 최소 하나가 있어야 한다.
- 자바는 실행 시점에 main 이라는 이름의 스레드를 만들고, 프로그램의 시작점인 main() 메서드를 실행한다.

**스레드 생성 후**
- HelloThread 인스턴스의 start() 메서드를 호출하면 자바는 스레드를 위한 별도의 스택 공간을 할당한다.
- 스레드 객체를 생성하고, 반드시 start()를 호출해야 스택 공간을 할당 받고 스레드가 작동한다.
- 스레드의 이름을 부여하지 않으면, 자바가 Thread-0, Thread-1과 같은 임의의 이름을 부여한다.
- 생성된 새로운 스레드는 run() 메소드의 스택 프레임을 스택에 올리면서 run() 메소드를 시작한다.

**메서드를 실행하면 스택 위에 스택 프레임이 쌓인다**
- main 스레드는 main() 메서드의 스택 프레임을 스택에 올리면서 시작한다.
- 직접 만드는 스레드는 run() 메서드의 스택 프레임을 스택에 올리면서 시작한다.

**스레드 분석 - 시간의 흐름**
<img width="745" height="393" alt="image" src="https://github.com/user-attachments/assets/b46b2d41-33ae-4f58-abaa-041a7c24ef48" /> <br />
- main 스레드가 HelloThread 인스턴스를 생성한다. 이때 스레드에 이름을 부여하지 않으면 자바가 임의의 이름을 부여한다.
- start() 메서드를 호출하면, Thread-0 스레드가 시작되면서 Thread-0 스레드가 run() 메서드를 호출한다.
- 여기서 핵심은 main 스레드가 run() 메서드를 실행하는게 아니라 Thread-0 스레드가 run() 메소드를 실행한다는 점이다.
- 메인 스레드는 단지 Thread-0 스레드에게 실행을 지시한다.
- 이로써, 메인 스레드와 Thread-0 스레드는 동시에 실행된다.
- 메인 스레드의 입장에서 보면 1,2,3번 코드를 멈추지 않고 계속 수행하고, run() 메소드는 메인 스레드가 아닌 별도의 스레드에서 실행된다.

**스레드 간 실행 순서는 보장되지 앟는다.**
- 스레드는 동시에 실행되기 때문에 스레드 간 실행 순서는 얼마든지 달라질 수 있다.
  <img width="704" height="716" alt="image" src="https://github.com/user-attachments/assets/2ea5d002-93bb-4fb8-b32c-704a10aea0d2" />
- 스레드는 순서와 실행 기간을 모두 보장하지 않는데, 이것이 바로 **멀티 스레드**이다.

  ### start() vs run()
  - 스레드의 start() 대신에 재정의한 run() 메소드를 직접 호출한다면?
```java
public class BadThreadMain {

    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName() + ": main() start");

        HelloThread helloThread = new HelloThread();
        System.out.println(Thread.currentThread().getName() + ": start() before");
        helloThread.run(); //직접 호출
        System.out.println(Thread.currentThread().getName() + ": start() after");

        System.out.println(Thread.currentThread().getName() + ": main() end");
    }

}
```
<img width="715" height="303" alt="image" src="https://github.com/user-attachments/assets/cd8cf745-abd8-4bb6-8658-0863a33b334e" /> <br />

- 위 코드의 경우 별도의 스레드가 run()을 실행하는 것이 아니라, amin 스레드가 run() 메서드를 호출한다.
- 메인 스레드가 run() 메서드를 실행했기 때문에 메인 스레드가 사용하는 스택 위에 run() 스택 프레임이 쌓인다.

<img width="717" height="354" alt="image" src="https://github.com/user-attachments/assets/2d2f2ca3-7ffa-45dc-a805-ee06671b3f8f" /> <br />
- 결과적으로 메인 스레드에서 모든 것을 처리하게 된다.
- 스레드의 start() 메서드는 스레드에 스택 공간을 할당하면서 스레드를 시작하는 메서드이다. 그리고 해당 스레드에서 run() 메서드를 실행한다.
- 따라서 메인 스레드가 아닌 별도의 스레드에서 재정의한 run() 메서드를 실행하려면, 반드시 start()를 호출해야 한다.

### 데몬 스레드
- 스레드는 사용자 스레드와 데몬 스레드로 구분할 수 있다.

**사용자 스레드**
- 프로그램의 주요 작업을 수행한다.
- 작업이 완료될 때까지 실행된다.
- 모든 유저 스레드가 종료되면, JVM도 종료된다.

**데몬 스레드**
- 백그라운드에서 보조 작업을 수행한다.
- 모든 유저 스레드가 종료되면, 데몬 스레드는 자동으로 종료된다.

> JVM은 데몬 스레드의 실행 완료를 기다리지 않고 종료된다. 데몬 스레드가 아닌 모든 스레드가 종료되면, 자바 프로그램도 종료된다.

```java
public class DaemonThreadMain {

    public static void main(String[] args) {
        Logger.start();

        DaemonThread daemonThread = new DaemonThread();
        daemonThread.setDaemon(true); //set daemon thread
        daemonThread.start();

        Logger.end();
    }
}
```

```java
public class DaemonThread extends Thread {

    @Override
    public void run() {
        Logger.start();

        try {
            Thread.sleep(10000); //execute 10sec
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        Logger.end();
    }
}
```
**실행 결과**
<img width="715" height="181" alt="image" src="https://github.com/user-attachments/assets/173e464b-dc37-45d3-a0a8-049afc3159b6" /> <br />

- 유저 스레드인 main 스레드가 종료되면 자바 프로그램이 종료된다.
- 데몬 스레드는 10초간 대기하고 있지만, 유저 스레드인 메인 스레드가 종료되면, 데몬 스레드도 종료되기 때문에 end 부분이 출력되지 않는다.


<img width="704" height="178" alt="image" src="https://github.com/user-attachments/assets/d1e4872a-e4b0-4250-9d73-42827f491ee1" /> <br />
- Thread-0이 유저 스레드로 설정된다.
- 따라서, 메인 스레드가 종료되어도, Thread-0 이라는 유저 스레드가 종료될 때 까지 자바 프로그램이 종료되지 않는다.
- THread-0: run() end가 출력된다.

### 스레드 생성 - Runnable
- 스레드 생성 시 Runnable Interface를 구현하는 방식으로 진행해보자.

```java
package java.lang;
public interface Runnable {
  void run();
}
```

```java
public class HelloRunnable implements Runnable {
    @Override
    public void run() {
        Logger.start();
    }
}
```

```java
public class HelloRunnableMain {

    public static void main(String[] args) {
        Logger.mainStart();
        HelloRunnable helloRunnable = new HelloRunnable();
        Thread thread = new Thread(helloRunnable);
        thread.start();
        Logger.mainEnd();
    }
```
- 실행 결과는 기존과 같다.
- 차이가 있다면, 스레드와 해당 스레드가 실행할 작업이 서로 분리되어 있다는 점이다.
- 스레드 객체 생성 시, 실행할 작업을 생성자로 전달하면 된다.

### Thread 상속 vs Runnable 구현
- 스레드 사용 시 Runnable Interface를 구현하는 방식을 사용하자.

**Thread 클래스 상속 방식**
**장점**
- 간단한 구현
**단점**
- 상속의 제한 : 자바는 단일 상속만을 허용하므로, 다른 클래스를 상속받고 있는 경우 Thread 클래스를 상속 받을 수 없다.
- 유연성 부족 : 인터페이스를 사용하는 방법에 비해 유연성이 떨어진다.

**Runnable Interface를 구현하는 방식**
**장점**
- 상속의 자유롤움 : 다른 클래스를 상속받아도 문제없이 구현 가능
- 코드의 분리 : 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
- 여러 스레드가 동일한 Runnable 객체를 공유할 수 있어 효율적인 자원 관리가 가능하다.
**단점**
- 코드가 약간 복잡해질 수 있다.
  - Runnable 객체를 생성하고 이를 스레드에 전달하는 과정이 추가된다.

> Runnable 인터페이스로 스레드 생성 시, 스레드와 실행할 작업을 명확히 분리하고, 인터페이스를 사용하므로 Thread 클래스를 직접 상속하는 방식보다 유연하고 유지보수 하기 쉬운 코드를 만들 수 있다.
